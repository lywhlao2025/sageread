# SageRead 项目编码规范

## 角色
专业的编程专家（能够理解 Tauri + React + Rust 组合架构，保持跨端稳定性）。

## 目标
构建高可维护性、稳定性的项目，降低回归风险与维护成本，确保每次变更可追踪、可测试、可回滚。

## 上下文
需深入理解当前项目结构、依赖与既有设计，再进行修改。避免不必要的重构，优先在既有模块内完成需求。
对于用户需求，必须理解非常清楚，拆解成可执行的步骤，若有不确定的地方，一定要和用户确认。
上下文补充：
- 明确用户目标与范围：是否是功能新增、修复、优化或仅文档更新。
- 识别关键路径：影响用户体验的核心流程需优先保证稳定。
- 列出依赖与前置条件：涉及接口、数据、配置或环境的前置要求需先确认。
- 识别隐含假设：如果实现依赖默认配置/数据状态，必须显式记录。
- 评估影响面：关联模块、跨仓联动、兼容性与迁移成本。
- 明确验收标准：输出可验证的结果与检查点。

## 项目结构认知
- 前端主应用：`packages/app/src`
- Tauri 后端：`packages/app/src-tauri`
- 共享库：`packages/foliate-js`、`packages/app-tabs`
- 配置/脚本：`packages/app/vite.config.ts`、`packages/app/package.json`
- 依赖管理：`pnpm-workspace.yaml` + `pnpm-lock.yaml`

## 架构原则
- 前端（React）负责 UI 与状态管理，后端（Tauri/Rust）负责本地数据与系统能力。
- 所有与 Tauri API 的交互必须封装在 `services/` 或 `lib/` 层，不直接散落在组件中。
- 任何跨层交互都应有稳定接口，不随意打通内部结构。

## 编码规范

### 基本原则
- 易懂：代码意图清晰，命名直观，逻辑可读。
- 最小改动：只修改与需求相关的内容，避免波及无关模块。
- 模块化：拆分关注点，保持单一职责。
- 兼容既有架构：遵循当前项目的目录结构与依赖方式。
- 可回滚：变更不应破坏旧逻辑，必要时引入 feature flag。

### 注释要求
- 必要注释：仅在逻辑复杂、易误解处添加简洁说明。
- 方法注释：包含“入参”和“返回值”说明（参数含义、边界条件）。
- 类注释：说明该类的职责与用途。
- 注释不重复代码本身，不写“显而易见”的注释。

### 代码风格
- 保持现有代码风格与命名习惯。
- 不引入无关依赖或多余抽象。
- 变更范围尽量小，减少合并与回滚风险。
- 默认使用 TypeScript 的明确类型，不使用 `any` 逃避类型约束。

## 模块化与职责边界
- 组件只做 UI 与交互，业务逻辑集中在 hooks/services。
- 网络请求集中在 `services/`，并统一处理异常与超时。
- 状态管理集中在 `store/`，禁止直接跨组件修改全局状态。
- utils 不依赖 React/Tauri，保持纯函数优先。

## React 编码规范
- Hooks 必须是稳定依赖（useEffect 依赖完整，避免潜在状态错乱）。
- 组件拆分以“可测试”和“可复用”为前提，避免深层嵌套。
- 使用 `useMemo/useCallback` 的场景要明确收益，避免过度优化。

## Tauri 交互规范
- 所有 `@tauri-apps/*` 调用必须经由封装函数（service/lib）。
- 前端调用 `invoke` 时统一处理异常，错误必须可追踪。
- Tauri 侧命令命名应清晰，参数明确，返回值结构稳定。

## 错误处理规范
- 任何异步调用必须捕获错误（`try/catch` 或 `.catch`）。
- 错误信息需有上下文（函数/业务场景/关键参数）。
- UI 错误要有用户可理解的提示。

## 日志与可观测性
- 重要流程需输出最小必要日志，避免污染控制台。
- 错误日志必须包含关键字段，便于定位。
- 不在生产环境输出敏感信息。

## 国际化（i18n）
- UI 文案必须走 i18n 字典，禁止硬编码。
- 新增文案需补全所有已有语言。
- 文案要简洁一致，避免同一含义多处不同翻译。

## 性能要求
- 不做无意义的全量渲染或频繁 state 更新。
- 长列表使用分页/虚拟化。
- 高频操作使用缓存或节流。

## 安全与稳定性
- 严禁拼接 SQL、避免注入风险。
- 外部输入要校验与清洗。
- 本地文件操作必须做存在性与权限判断。

## 测试与质量保障
- 所有改动完成后必须跑通所有测试用例。
- 如测试失败，需先修复再提交。
- 新增功能需要补充对应测试（单元或端到端），确保可回归。
- 对关键路径必须覆盖 E2E 测试，避免发布后人工回归。

## 自动化回归流程
- 单元测试：验证纯逻辑模块（utils/services）。
- E2E 测试：覆盖关键业务流程（阅读/标注/聊天/笔记）。
- 视觉回归：对核心页面做截图对比，变化需人工确认。
- CI 中强制执行测试，失败即阻断合并。

## Git 提交规范
- 遵循主流 GitHub/Conventional Commits 习惯：
  - feat: 新功能
  - fix: 修复问题
  - refactor: 重构（不改变功能）
  - chore: 构建/脚本/工具类变更
  - docs: 文档更新
  - test: 测试相关
- 提交信息应简洁明确，概括改动意图。
- 每次提交需确保可构建、可测试、可回滚。

## 提交前检查清单
- 代码通过 lint/typecheck/test。
- 无无关改动，未引入多余依赖。
- 文档同步更新（如涉及 API/行为变化）。
- 关键功能手动抽检通过（如自动化未覆盖）。
- 如 git push 失败，可执行 `proxy_on` 开启代理网络后重试。

## 跨仓协作规范（sageread + sageReadServer）
当需求涉及前后端联动时，必须一次性统一处理两个仓库，避免重复沟通与遗漏。

### 跨仓需求输入模板
```
[目标]
一句话描述功能目标。

[涉及仓库]
- sageread（前端）
- sageReadServer（后端）

[功能说明]
- 用户行为：
- 预期效果：

[接口改动]
- 新增/修改接口：
- 参数/返回：

[数据改动]
- 数据库/缓存/队列：

[兼容性]
- 是否兼容旧版本？
- 是否需要降级逻辑？

[验收标准]
- 前端看到什么
- 后端日志/接口响应
```

### 执行规则
- 必须同时读取两仓的 `AGENTS.md` 并遵循规范。
- 在单次回复中给出跨仓改造计划与改动点。
- 任何跨仓改动必须同步更新相关文档。

## 测试与质量保障
- 所有改动完成后必须跑通所有测试用例。
- 如测试失败，需先修复再提交。
- 新增功能需要补充对应测试（单元或端到端），确保可回归。

## Git 提交规范
- 遵循主流 GitHub/Conventional Commits 习惯：
  - feat: 新功能
  - fix: 修复问题
  - refactor: 重构（不改变功能）
  - chore: 构建/脚本/工具类变更
  - docs: 文档更新
  - test: 测试相关
- 提交信息应简洁明确，概括改动意图。
